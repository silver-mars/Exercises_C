# Быстрая работа в консоли #

**GUI vs. CLI**<br>
GUI - (Graphical user interface) - это графическая оболочка, наиболее известная нам по системе Windows (окна, ярлыки. Клики мышкой - основной способ управления системой).<br>
CLI - (Command-line interface) - интерфейс командной строки - другой вариант взаимодействия человека и компьютера. Ввод текста в консоль - основной способ общения с системой.<br>
В интернете есть много статей на тему GUI против CLI и так как наша статья немного проходится по ней, я сделаю краткий обзор.

Обычно битва этих титанов (в невыгодном для графики виде) выглядит так:
>"Уберите руку с клавиатуры и возьмите мышь, перейдите в панель запуска программ и найдите нужный текстовый редактор. Откройте программу. Щелкните в области редактирования текста. Уберите руку с мыши и введите “Hello World” в файл. Уберите руку с клавиатуры и возьмите мышь, перейдите к значку или пункту меню, чтобы сохранить файл. Выберите место для его сохранения. Закройте файл.<br>
>Теперь, вместо этого, введите Ctl + Alt + T (или любой способ вызвать терминал) и введите ‘echo “Hello World”> ~ /myfile.txt'".<br>
Взято у Джейсона Престона не могу найти откуда.

**Преимущества CLI:**
1. В графическом интерфейсе вы ограничены дизайном программиста (вы можете выполнять только те функции, иконки которых найдёте + всякий раз их ещё разглядеть нужно).
Для примера что быстрее:
зайти, кликая мышкой, в какую-нибудь глубоковложенную папку с логами
или просто вбить её путь в bash'e? (при условии, что вы его знаете)
2. По сути выполнение операций в графической оболочке - это то же самое общение с системой, просто добавляются дополнительные накладные расходы на графику, которые необходимо визуализировать и иногда обновлять каждые несколько секунд. (Например, открыть в проводнике папку "Downloads" - это то же **cd ~/Downloads**, просто со спецэффектами и озвучкой).<br>
Эта нагрузка на графику часто занимает больше памяти, чем сама задача.

С другой стороны в момент исполнения команды в консоли, выполняется только поставленная задача и всё получается быстрее. 
При этом я не утверждаю, что нужно пользоваться только консолью, есть вещи, которые проще и быстрее сделать через GUI (например, взятие скриншотов).
Но раз уж по долгу работы нам приходится работать в консоли, то давайте делать это быстро, профессионально и с минимумом усилий.
Позволю напомнить себе древнуюю истину:<br>
*"Хороший системный администратор - это ленивый системный администратор".*

Тезис:<br>
Большинство операций, которые выполняются с помощью мыши, могут быть сделаны без неё, быстрее и проще, а иногда их и вовсе можно автоматизировать.
Вы работаете на Линукс, которая изначально затачивалась на чистую работу с консолью, а значит вы можете значительно ускорить свою работу, просто запомнив и начав применять некоторые трюки по работе с CLI.

Вот они:

## bash оболочка. Hotkeys ##

<details>
    <summary>Спойлер</summary>

<pre>Ctrl + Shift + T -> открыть вторую вкладку в терминале.
Ctrl + Page_Up -> переключиться на соседнюю вкладку в терминале (справа).
Ctrl + Page_Down -> переключиться на соседнюю вкладку в терминале (слева).
Те же самые быстрые переключения между вкладками работают в Firefox, Chrome и даже Dbeaver - всё сделано для вашего удобства!

Бывает ли такое, что вам нужно стереть что-то в консоли и написать вместо этого что-нибудь другое? Если да и для этой цели вы жмёте backspace несколько секунд,
а потом, иногда, удаляете лишнее и, ругаясь начинаете набирать заново, то есть полезные клавиши и на этот случай жизни:
Ctrl + W -> стереть одно слово слева от курсора.
Ctrl + U -> стереть всю строку слева от курсора.
Ctrl + K -> стереть всю строку справа от курсора.
И немного выбивающийся из колеи:
Alt + D -> стереть слово справа от курсора.
Кстати, эти команды не просто удаляют эти символы безвозвратно, они копируют их во внутренний буфер обмена и следующая комбинация:
Ctrl + Y -> позволяет вставлять их в командную строку обратно (на случай, если вы вдруг ошиблись и стёрли лишнее).
Ctrl + D -> стереть символ под курсором (вот эта команда во внутренний буфер не идёт, но от случайных ошибок в ней может спасти следующая:) 
Ctrl + Shift + '-' или Ctrl + X + U -> просто отменить последние изменения в консоли.
Ctrl + X + E -> копирует всю текущую, набранную в консоли строку, в ваш editor по умолчанию. Помогает в случае, если вам нужно сохранить себе эту команду.
(См. команды editor и sudo update-alternatives --config editor)

Следующие две комбинации хорошо работают в сочетании с клавишами стирания (Ctrl + W, Ctrl + K, etc.):
Ctrl + A -> быстрое перемещение в начало строки. (Довольно просто запомнить - с буквы А начинается алфавит)
Ctrl + E -> быстрое перемещение в конец строки. (Тоже просто - E - End).
Также две удобные комбинации, когда используются просто стрелки:
Ctrl + Left - переместиться на одно слово влево.
Ctrl + Right - переместиться на одно слово вправо.
Однажды освоив их в консоли, вы начнёте применять их в телеграмме, вк и прочих приложениях, где есть поля набора текста, потому что это очень здорово сокращает беготню
по текстовым полотнам.
Опять же удобно применять их с клавишами стирания, чтобы быстро изменить нужную команду (или с зажиманием клавиши Shift, чтобы выделить всё слово сразу (но не в консоли))
Так же есть две, иногда полезные, комбинации:
Alt + C -> Case upper - заменить стоящую под курсором букву на заглавную.
Alt + L -> lower - заменить стоящую под курсором букву на строчную.
Ctrl + X + X - первое нажатие вернёт вас в начало строки, второе - в то место, где курсор находился изначально.</pre>

</details>

## Общая оптимизация скорости работы ##

Как это всё можно оптимизировать?<br>
**1-ый пример** приведём на любимом нами kubernetes.<br>
Типичная проверка состояния нэймспейса (а затем и чтение логов нужного нам микросервиса) выглядят так:<br>
**kubernetes get po -n my-namespace**<br>
**kubernetes logs my-service-blablabla-blabla -n my-namespace**<br>
И чтобы после первой команды набрать вторую, мы вынуждены либо набирать всю команду заново, либо много раз жать стрелку влево, затем много раз Backspace, после чего уже записывать нужную нам часть команды.<br>
Увеличить скорость работы в этом примере можно двумя способами:<br>
1-ый - использовав мозг:<br>
Команды можно записать следующим образом:<br>
**kubernetes -n my-namespace get po**<br>
**kubernetes -n my-namespace logs my-service-blablabla-blabla**<br>
В данном случае нам уже не нужно возвращаться в середину команды, чтобы стереть нужный участок. Мы жмём стрелку "вверх", чтобы вызвать предыдущую команду и сразу можем жать Backspace, стирая ненужное и записывая нужное.<br>
Второй способ, как вы наверное уже догадались, это hotkeys.<br>
Нужно зажать Ctrl и, удерживая его, дважды нажать "W". И вот команда **get po** уже стёрта и вы можете писать **logs blablabla**.<br>
Идеально - использовать оба способа.<br>

**2-ой пример:**<br>
нам часто нужно искать данные в локальных логах, зачастую команды при этом выглядят так:<br>
**grep -C 50 repproduced /opt/srv/logs/srv_important.log**<br>
По умолчанию, чтобы что-то изменить в этой команде, нам опять же нужно лезть в середину команды, удалять ненужное, дописывать нужное.<br>
Уже здесь, как вы понимаете, можно довольно быстро ускориться, либо прыгнув сразу в начало консоли "Ctrl + A" и/либо перескочив нужные нам слова "Ctrl + Right | Ctrl + Left".<br>
Но, используя мозг, можно переписать всю команду следующим образом:<br>
**cat /opt/srv/logs/srv_important.log | grep -C 50 my_meta_data.**<br>
Поначалу это может казаться усложнением: мы сперва даём команду прочитать все логи, а затем перенаправляем вывод на grep, но если присмотреться к этому трюку повнимательнее, то мы увидим, что теперь, чтобы переписать ту часть, где мы что-то ищем, нам достаточно вызвать предыдущую команду и один раз нажать "Ctrl + W".<br>

В этом месте я вынужден напомнить, что при таком подходе мы всё равно вынуждены либо писать первую команду целиком, либо искать её по истории сообщений командой:<br>
**history | grep cat** (*подробнее про манипуляции с введёнными ранее командами, history и её переменные см.* [rus-linux.net](http://rus-linux.net/MyLDP/BOOKS/Linux_Foundations/14/ch14.html?ysclid=lcad7ang48401895137))<br>
Однако есть и другой метод, чтобы избегнуть этой части рутины: просто написать небольшой bash-скрипт.<br>
Если развивать последний пример, то скрипт может выглядеть, например, так:<br>
```
#!/bin/bash

cat /opt/srv/logs/srv_important.log | grep -C 40 "$1" --color=auto</pre>
```
<details>
    <summary>Спойлер</summary>

**#!/bin/bash** - сообщает системе, что это исполняемый файл для bash.<br>
**"$1"** - это первый аргумент после команды, место, куда мы вставляем искомое слово.<br>
**--color=auto** я дописал, чтобы он подсвечивал красным найденное, потому что по умолчанию скрипты не считывают стандартные alias'ы

</details>

Теперь вам достаточно назвать этот скрипт с какой-нибудь уникальной буквы (чтобы после неё можно было сразу добивать tab'ом всё название, в этом примере я назову **srv_log.sh**) и написать в командной строке<br>
**bash s<tab> <слово для поиска>**<br>
Всё, перед вами лог, и вам не нужно тратить время для набора всей команды или поисков по истории сообщения.<br>
При желании тот же скрипт можно дополнить, чтобы он искал по нужному вам пути (или написать несколько скриптов, чтобы один смотрел в барк, другой в финалайзер. Здесь вас ограничивает только ваша фантазия)

## И ещё несколько трюков ##

Которые помогут вам избежать длинных названий файлов и команд:<br>
Если вам часто нужно писать команды типа:<br>
<details>
    <summary>Спойлер</summary>

kafkacat -C -b **gitlab-ci-sand-awesome.ru:9092** -t sand-confirmed -o beginning<br>
kafkacat -C -b **test-gitlab-ci-node-awesome.ru:9092** -t test-confirmed -o beginning<br>
kafkacat -C -b **pred-gitlab-ci-node-brilliant.ru:9092** -t pred-confirmed -o beginning<br>
kafkacat -C -b **prod-gitlab-ci-node-amazing.ru:9092** -t prod-confirmed -o beginning
или
/opt/kafka/bin/kafka-console-consumer.sh --bootstrap-server **15.83.178.212:9092** --group node-integrator --topic sand-node-response
/opt/kafka/bin/kafka-console-consumer.sh --bootstrap-server **16.84.179.213:9092** --group node-integrator --topic test-node-response
/opt/kafka/bin/kafka-console-consumer.sh --bootstrap-server **17.85.180.214:9092** --group node-integrator --topic pred-node-response

</details>

где нужны разные переменные, в зависимости от типа окружения/левой-ноги-заказчика/чего-бы-то-ни-было-ещё, то можно загнать их в alias или в переменные в своём .bashrc<br>
*(bash run command - исполняемый файл, который содержит все сокращения, которыми мы так любим пользоваться.)*<br>
Пример на аналогии:
<details>
    <summary>Спойлер</summary>

любимая нами команда **ll** на самом деле в ~/.bashrc выглядит так:<br>
**alias ll='ls -alF'**<br>
а несколькими строчками выше ls зашифрована как:<br>
**alias ls='ls --color=auto'**<br>
Поэтому когда вы незатейливо набираете в консоли ll, bash в этот момент, руководствуясь вшитыми в ~/.bashrc инструкциями, исполняет команду:<br>
**ls -alF --color=auto** подсвечивая разными цветами разные типы файлов ради вашего удобства.

</details>

Возвращаясь к нашему примеру, мы можем создать следующие переменные, дописав их, к примеру, в конец своего .bashrc:<br>
**export sand='gitlab-ci-sand-awesome.ru:9092'**<br>
**export test='test-gitlab-ci-node-awesome.ru:9092'**<br>
**export pred='pred-gitlab-ci-node-brilliant.ru:9092'**<br>
**export prod='prod-gitlab-ci-node-amazing.ru:9092'**<br>
Теперь мы смело можем считывать данные с нужного адреса, используя эти переменные:<br>
kafkacat -C -b **$sand** -t confirmed -o beginning<br>
kafkacat -C -b **$test** -t confirmed -o beginning<br>
kafkacat -C -b **$pred** -t confirmed -o beginning<br>
kafkacat -C -b **$prod** -t confirmed -o beginning<br>
*($ для bash обозначает, что сразу после этого знака идёт переменная.)*<br>
И нам не нужно лезть в values/сторонний файл/куда-либо ещё, где мы храним все эти названия, после чего делать copy-past в консоль или ещё как-либо тратить своё время на то, чтобы прочитать сообщения из нужного источника.<br>
*(Главное перезагрузить оболочку или набрать команду bash, чтобы он заново считал переменные из bashrc).*<br>

Что касается **alias**, их тоже полезно использовать в своей среде.<br>
Рассмотрим следующий случай: допустим вам часто приходится заглядывать в содержимое виртуальной файловой системе по текущей дате.<br>
Для этого нужна команда вроде:<br>
**cd /mnt/tmp/nfs/docs/2022-12-30** (день написания данной статьи).<br>
Чтобы каждый раз не вбивать долго и муторно весь этот путь, вы можете вбить его в alias по такому примеру:<br>
<details>
    <summary>Спойлер</summary>

**alias pn='cd /mnt/tmp/nfs/docs/'$(date +%F)' && ls -l'**<br>
**&&** обозначает, что команда после этих символов исполнится только в случае успешного исполнения предыдущей части команды.<br>
Можно заменить её на символ **";"**. Он обозначает, что сперва выполняется предыдущая часть команды, а затем, вне зависимости от результата, правая часть команды. (Но тогда, если переход не выполнится, то вы просто увидите содержимое текущей папки)<br>
**$(date +%F)** обозначает, что перед тем, как исполнить этот скрипт, выполняется команда **date +%F**, которая подставляет вместо себя текущую дату (в моём случае - 2022-12-30).

</details>

Так что в итоге я вбиваю в консоли **pn**, жму Enter, и он переходит в директорию:<br>
/mnt/tmp/nfs/doc/2022-12-30, после чего выполняет команду **ll** (*или, вернее, ls='ls --color=auto' - помним про alias*) и я сразу вижу всё содержимое этой директории.<br>
Главное - подобрать понятную для вас мнемонику.<br>
Я, например, **pn** расшифровываю для себя как **path** to **nfs**.<br>

Ещё можно настроить автодополнение в кубере таким образом, чтобы вместо **kubectl** вы вводили только одну букву: **k**.<br>
Для этого мы можем выполнить следующую команду:<br>
**1. kubectl completion bash > kub.sh**<br>
затем зайти в неё, видоизменить последние строки:<br>
<details>
    <summary>Спойлер</summary>


```
if [[ $(type -t compopt) = "builtin" ]]; then
    complete -o default -F __start_kubectl kubectl
else
    complete -o default -o nospace -F __start_kubectl kubectl
fi
```
До следующего вида:

```
alias k=kubectl

if [[ $(type -t compopt) = "builtin" ]]; then
    complete -o default -F __start_kubectl kubectl
    complete -o default -F __start_kubectl k
else
    complete -o default -o nospace -F __start_kubectl kubectl
    complete -o default -o nospace -F __start_kubectl k
fi
```

</details>

**2. Вписать строку в своём ~/.bashrc:**

```
source ~/kub.sh
```
(Другой вариант - просто перенести файл kub.sh в /etc/profile.d, если у вас есть такие права.)

**3. Перезайти.**

### Хитросплетённые команды, о существовании которых нужно знать и периодически подглядывать в них, если они вдруг становятся актуальны, а вы их не помните ###

Иногда у нас в одной директории находится очень много файлов и прошерстить их все и сразу командой типа **grep "something" ./**\* не представляется возможным.<br>
В такие моменты баш пишет вам что-то вроде:<br>
<pre>bash: /usr/bin/grep: Argument list too long</pre>
Избежать этого можно с использованием опций крайне полезной команды **find**, например так:<br>
**find . -type f -exec grep "something" {} +**
<details>
    <summary>Спойлер</summary>

Здесь **find .** обозначает, что нужно искать в текущей директории (вместо точки можно писать абсолютный путь)<br>
**-type f** обозначает, что искать нужно только файлы (f - files)<br>
**-exec grep "something"** - exec - execute - "выполнить" команду grep с любыми вашими опциями.<br>
В конце обязательно **{} +** - оно означает, что все найденные командой find файлы будут по одному вставляться в фигурные скобки как аргументы для команды **grep** в нашем случае.

</details>

Соответственно в **grep** можно вписывать любые свои флаги, например **-l** - выводить только имена файлов без содержимого.<br>
Если файлов настолько много, что даже такая команда будет выполняться чрезвычайно долго, но при этом вам известно время создания файла, вы можете использовать расширенные флаги команды **find**, например, следующая команда:<br>
**find . -type f -newermt '2022-03-04 17:25:00' ! -newermt '2022-03-04 17:30:00' -exec grep -l "my-awesome-search" {} +**<br>
сперва найдёт все файлы, которые изменялись в промежутке с 17:25:00 до 17:30:00 указанной даты, а затем уже применит к ним **grep**.<br>
**Примечание:** можно указывать только дату. Подробнее про манипуляции со временем вы можете посмотреть, например, здесь: [dmosk.ru/miniinstruktions](https://www.dmosk.ru/miniinstruktions.php?mini=search-linux&ysclid=lcowsa1cy7943112085)

Надеюсь эти трюки облегчат вашу жизнь и позволят уменьшить количество рутины в повседневной работе, ускорить выполнение ежедневных квестов и оставить время для отдыха, глубокомысленных философских мыслей или изучения каких-нибудь других, полезных для вас, ресурсов.

В качестве маленького бонуса - пример синтеза лучших качеств от GUI и CLI:
<details>
    <summary>Спойлер</summary>

На примере программы flameshot в Ubuntu:<br>
сперва установите её командой:
<pre><code class="shell">
sudo apt install flameshot
</code></pre>
дальше попробуйте ввести в консоль команду **flameshot gui**<br>
и, обратите внимание, в момент захвата экрана вам сперва дадут подсказки по hot keys<br>
e. g.:<br>
Ctrl + S - save to file,<br>
Ctrl + C - save to clipboard, etc.<br>
При этом вы можете их проигнорировать и сразу начать работать:<br>
выделить нужный участок экрана, разместить на нём стрелки-указатели, выделить что-то, подчеркнуть аккуратными прямыми линиями, ввести текст и т. д.

Однако для полного счастья я предлагаю зайти дальше:<br>
откройте на своём компьютере **Settings**, зайдите во вкладку **Keyboards** и найдите на ней блок **Keyboard shortcuts**.<br>
Выберите в **View and customize shortcuts**, раздел **Screenshots**.<br>
Отключите текущую настройку **Take a screenshot**, если она занимает клавишу **PrintScreen**<br>
Зайдите во вкладку **custom shortcuts** и добавьте новую.<br>

Вам предложат ввести её название (я назвал просто - flameshot),<br>
заполнить поле command - для этого наберите в консоли<br>
<pre><code class="shell">
which flameshot
</code></pre>
(скорее всего у вас будет путь вроде /usr/bin/flameshot)<br>
а теперь запишите в поле **Command** этот путь и добавьте к нему флаг gui (Пример - /usr/bin/flameshot gui).<br>
Всё, теперь осталось только кликнуть на **set shortcut** и нажать на кнопку PrintScreen, чтобы она установилась, как вызывающая введённую выше команду.

Это хороший пример объединения лучших качеств GUI и CLI.

</details>
